---
layout: post
title: "MySQL数据库设计规范"
date: 2018-02-06 
description: "MySQL设计规范"
tag: MySQL
---   


> 为了提高代码的可维护性, 健壮性, 良好的阅读性, 通常我们要制定一套代码规范来约束团队的开发人员, 以便整个团队能保持统一的风格, 数据库在设计和使用的时候也不例外, 需要有一套良好的规范来支撑我们的不断增长的业务.

下面来介绍一下数据库相关的规范

### 命名规范
*inux系统上对大小写是敏感的, 为了在任何环境下我们都能正确的使用数据库相关的东西, 我要要遵循如下规范:
* 所有名称应该做到见名知义, 便于理解
* 数据库对象名,表名,字段名, 统一使用小写, 采用下划线连接, 数据库名表名带上业务名称 
* 表名,字段名不要超过32个字符
* 所有存储相同内容的字段名和字段类型必须一致
* 禁止使用MySQL关键字和保留字命名
* 临时库必须以 tmp为前缀且以日期为后缀, 便于日后区分和管理
* 备份库,备份表必须以.bak为前缀且日期为后缀命名

#### 实例1: 数据库对象和表命名
```text
数据库命名: qq_userdb
表命名: user_account
临时表: tmp_access_log_20180101
```

`小知识`: [MySQL保留字:参考官方文档](https://dev.MySQL.com/doc/refman/5.7/en/keywords.html)



### 建表规范
* 所有表必须使用Innodb存储引擎(除非不能满足需求)
原因: MySQL5.5之前默认使用MyISAM, MySQL5.6之后默认使用 Innodb存储引擎, Innodb支持事务, 行级锁, 有更好的恢复性, 在高并发情况下性能更好

* 数据库和表的字符集统一使用UTF8, 避免由于字符集不统一产生乱码问题

* 使用comment给表和字段添加合适的备注, 便于阅读, 且从建表开始就进行`数据字典`的维护, 避免由于人员变动带来额外成本

* 单表数据量控制在500万行以内(非MySQL限制, 限制取决于存储设备和文件系统, 例如32位系统和64位系统处理的字节数上限不一样)

* 超过500万行可以用 数据归档(日志), 和分库分表(主要适用于业务), 谨慎使用MySQL分区表(避免跨分区查询), 物理分表方式需要应用层进行判断

* 尽量减少字段, 把经常使用的列放到一个表中, 可以减少磁盘IO, 更好的利用缓存

* 禁止在表中预留字段(没意义, 增加修改成本, 字段名和类型都不确定)

* 禁止在数据库中存储图片, 文件等二进制类型, 避免降低数据库性能

* 禁止在线上做数据库压力测试


### 索引设计规范
索引是一把双刃剑, 我们利用地好能大大提高效率, 利用地不好也能降低效率, 我们需要遵守以下规范:
* 单表索引不超过5个
* 禁止给表中的每一列建立单独的索引
* 每个表必须有主键(最好是自增id),  不能使用更新频繁的字段作为主键, 不使用多字段主键
* 注意复合索引中字段的顺序
* 不要使用UUID, MD5, HASH等不规则字符串作为主键, 因为它们是无序的
* SQL中WHERE从句中的字段, 包含在ORDER BY, GROUP BY, DISTINCT 中的字段
* 多表JOIN的关联列建立索引
* 避免简历冗余索引和重复索引
* 尽量避免使用外键约束(MySQL检查外键参照完整性约束而降低性能), 给多表关联字段添加索引

`小知识` 索引能提高查询效率, 但是会降低修改和删除效率

`小知识` Innodb引擎的存储方式是索引组织, 即Innodb存储的时候的顺序和索引组织的顺序是一样的



`小知识` MySQL最多支持4096个字段, 每一行字节总数不能超过65535个字节



`小知识`: UTF8字符集汉字占3个字节, ASCII码占用1个字节


### 数据类型规范
* 优先选择复合存储需要的最小的数据类型, 尽量将字符串转换为数字类型存储,例如IP地址, INET_ATON('255.255.255.255') = 4294967295, INET_NTOA (4294967295) = '255.255.255.255'
* (同上)整型优先使用无符号(UNSIGNED)类型以提高存储范围
* 减少定义的字符串的长度
* 避免使用 TEXT, BLOB数据类型
* 避免使用 ENUM数据量类型(修改ENUM需要使用ALTER, 存在一定风险, ORDER BY操作效率低, 需要额外操作)
* 枚举类型使用数值类型存储
* 尽可能把字段定义字段为 NOT NULL(索引NULL字段需要额外空间来存储是否为NULL, 进行比较和计算时, 需要对NULL进行特殊处理, 可能导致索引失效)
* 不要使用字符串来存储日期型数据,使用TIMESTAMP(4Byte, 存储范围1970-01-01 00:00:01 ~ 2038-01-19 03:14:07, 比INT类型可读性高)或者DATETIME(8Byte)类型存储时间
* 财务相关金额数据, 必须使用 decimal类型, 避免计算丢失精度, decimal占用空间由定义的宽度决定, 可以存储比 bigint更大的整数数据(比varchar更高效)

### SQL开发规范
* 建议使用预编译语句进行数据库操作, 减少编译时间, 有效避免SQL注入问题
* 避免类型隐式转换(可能导致索引失效), 例如WHERE 中 整型和字符串类型转换
* 充分利用表上已经存在的索引
* 避免使用'%xx%' 或者 '%xxx', 模糊查询(无法有效利用索引, 'xx%'可以利用索引)
* 一个SQL中只能利用复合索引中的一个字段进行范围查询
* 使用LEFT JOIN NOT EXISTS来优化 NOT IN 操作 (NOT IN  可能导致索引失效)
* 程序连接不同的数据库使用不同的账号, 禁止跨库查询, 为数据库迁移和分库分表留出余地, 降低业务耦合度, 避免权限过大产生安全风险问题
* 禁止使用 SELECT *(无法使用覆盖索引) ,必须指明字段, 减少CPU,IO,网络带宽资源消耗, 还可以减少表结构的变更带来的影响
* 禁止使用不含有字段列表的 INSERT 语句, 必须明确指定每一个字段名, 
* 尽量避免使用子查询(返回的结果集无法使用索引, 它会被存储到临时表中, 产生大量慢查询), 可以把子查询优化为 JOIN操作
* 避免使用JOIN关联太多的表, 建议不超过5个(MySQL最多允许关联61个表)
* 尽量减少同数据库的交互次数, 数据库更适合处理批量操作, 合并多个相同的操作到一起, 可以提高处理效率
* 建议使用 IN 代替 OR, IN操作可以更好的利用索引
* 禁止使用 ORDER BY RAND() 进行随机排序, 因为这会消耗大量的CPU和IO及内存资源
* 禁止在WHERE从句中对字段进行函数转换和计算(对列进行函数转换或计算会导致无法使用索引), 可以使用其他方式(例如大小比较)转换
* 在明显不会有重复值的时候使用 UNION ALL 而不是 UNION, 因为 UNION 会把所有数据放到临时表中再进行去重操作, UNION ALL 不会再对结果集进行去重操作
* 拆分复杂的大SQL为多个小SQL(MySQL一个SQL只能使用一个 CPU进行计算, 如果拆分后则可以并行执行操作)

### 数据库操作行为规范
* 超过100万行的批量写操作, 要分批次进行操作(大批量操作可能造成严重的主从延迟, 会产生大量事务, 锁住数据库, 造成阻塞)
* 对于大表结构修改一定要谨慎, 会造成严重的锁操作, 推荐使用 `pt-online-scheme-change`修改表结构, 它可以避免修改大表产生的主从延迟问题, 避免在对表字段进行修改时进行锁表
* 禁止为程序使用的账号赋予 super权限(当MySQL达到最大连接数限制时, 还允许1个有super权限的用户连接), super权限只能留给DBA处理问题使用
* 对于程序连接数据库账号, 遵循权限最小原则, 程序使用数据库账号只能在一个DB下使用, 不允许跨库, 程序使用的账号原则上不准有drop权限



### 总结
上面所有的规范都是前人总结的经验, 并不总是不可违背, 你要自己权衡不遵循它所带来的问题, 一旦出现问题, 可能后悔莫及啊


(完)

转载请注明原地址，[本文首发于http://blog.nodejs.tech/](http://blog.nodejs.tech) 谢谢！
